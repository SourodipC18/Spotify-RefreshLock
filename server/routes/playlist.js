const express = require('express');
const router = express.Router();
const Playlist = require('../models/Playlist');
const spotifyService = require('../services/spotifyService');

// Get all playlists for a user
router.get('/user/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const playlists = await Playlist.find({ user_id: userId });
    res.json(playlists);
  } catch (error) {
    console.error('Error fetching user playlists:', error);
    res.status(500).json({ error: 'Failed to fetch playlists' });
  }
});

// Get specific playlist
router.get('/:playlistId', async (req, res) => {
  try {
    const { playlistId } = req.params;
    const { userId } = req.query;
    
    let playlist = await Playlist.findOne({ 
      playlist_id: playlistId, 
      user_id: userId 
    });

    if (!playlist) {
      // Try to fetch from Spotify and create new entry
      try {
        const spotifyPlaylist = await spotifyService.getPlaylist(playlistId);
        
        if (!spotifyService.isAutoGeneratedPlaylist(spotifyPlaylist)) {
          return res.status(400).json({ 
            error: 'This playlist is not auto-generated and cannot be frozen' 
          });
        }

        const tracks = await spotifyService.getPlaylistTracks(playlistId);
        
        playlist = new Playlist({
          playlist_id: playlistId,
          user_id: userId,
          name: spotifyPlaylist.name,
          description: spotifyPlaylist.description,
          current_version: {
            date: new Date(),
            tracks: tracks,
            snapshot_id: spotifyPlaylist.snapshot_id
          },
          version_history: [{
            date: new Date(),
            tracks: tracks,
            snapshot_id: spotifyPlaylist.snapshot_id
          }]
        });

        await playlist.save();
      } catch (spotifyError) {
        return res.status(404).json({ error: 'Playlist not found' });
      }
    }

    res.json(playlist);
  } catch (error) {
    console.error('Error fetching playlist:', error);
    res.status(500).json({ error: 'Failed to fetch playlist' });
  }
});

// Freeze/unfreeze playlist
router.post('/freeze', async (req, res) => {
  try {
    const { playlistId, userId, freeze } = req.body;
    
    let playlist = await Playlist.findOne({ 
      playlist_id: playlistId, 
      user_id: userId 
    });

    if (!playlist) {
      return res.status(404).json({ error: 'Playlist not found' });
    }

    playlist.frozen = freeze;
    playlist.updated_at = new Date();
    await playlist.save();

    res.json({ 
      message: `Playlist ${freeze ? 'frozen' : 'unfrozen'} successfully`,
      frozen: playlist.frozen 
    });
  } catch (error) {
    console.error('Error toggling freeze:', error);
    res.status(500).json({ error: 'Failed to toggle freeze' });
  }
});

// Get version history
router.get('/versions/:playlistId', async (req, res) => {
  try {
    const { playlistId } = req.params;
    const { userId } = req.query;
    
    const playlist = await Playlist.findOne({ 
      playlist_id: playlistId, 
      user_id: userId 
    });

    if (!playlist) {
      return res.status(404).json({ error: 'Playlist not found' });
    }

    res.json({
      current_version: playlist.current_version,
      version_history: playlist.version_history
    });
  } catch (error) {
    console.error('Error fetching version history:', error);
    res.status(500).json({ error: 'Failed to fetch version history' });
  }
});

// Revert to previous version
router.post('/revert', async (req, res) => {
  try {
    const { playlistId, userId, targetDate } = req.body;
    
    const playlist = await Playlist.findOne({ 
      playlist_id: playlistId, 
      user_id: userId 
    });

    if (!playlist) {
      return res.status(404).json({ error: 'Playlist not found' });
    }

    const targetVersionIndex = playlist.version_history.findIndex(
      version => new Date(version.date).toDateString() === new Date(targetDate).toDateString()
    );

    if (targetVersionIndex === -1) {
      return res.status(400).json({ error: 'Target version not found' });
    }

    await playlist.revertToVersion(targetVersionIndex);

    res.json({ 
      message: 'Playlist reverted successfully',
      current_version: playlist.current_version 
    });
  } catch (error) {
    console.error('Error reverting playlist:', error);
    res.status(500).json({ error: 'Failed to revert playlist' });
  }
});

// Update playlist (called periodically to create new versions)
router.post('/update/:playlistId', async (req, res) => {
  try {
    const { playlistId } = req.params;
    const { userId } = req.body;
    
    const playlist = await Playlist.findOne({ 
      playlist_id: playlistId, 
      user_id: userId 
    });

    if (!playlist) {
      return res.status(404).json({ error: 'Playlist not found' });
    }

    if (playlist.frozen) {
      return res.json({ message: 'Playlist is frozen, skipping update' });
    }

    // Fetch latest tracks from Spotify
    const tracks = await spotifyService.getPlaylistTracks(playlistId);
    const spotifyPlaylist = await spotifyService.getPlaylist(playlistId);
    
    // Add new version
    await playlist.addVersion(tracks, spotifyPlaylist.snapshot_id);

    res.json({ 
      message: 'Playlist updated successfully',
      current_version: playlist.current_version 
    });
  } catch (error) {
    console.error('Error updating playlist:', error);
    res.status(500).json({ error: 'Failed to update playlist' });
  }
});

module.exports = router;
